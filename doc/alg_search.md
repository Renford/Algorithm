
# 查找算法的基本概念

1. 无序查找：被查找数列有序无序均可
2. 有序查找：被查找数列必须为有序数列
3. 静态查找和动态查找：静态或者动态都是针对查找表而言的
4. 平均查找长度（Average Search Length，ASL）：需和指定key进行比较的关键字的个数的期望值

# 常见查找算法

## 顺序查找

属于无序查找算法，从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。

时间复杂度：O(N)

## 有序表查找

[Javascript代码看这里](../code/search/search_binary.js)

### 折半查找

又叫二分查找，被查找值递归与有序列表的中间值比较
    1. 等于，则查找成功
    2. 大于，则右半继续二分查找
    3. 小于，则左半继续二分查找

复杂度分析：最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)

__元素必须是有序的，如果是无序的则要先进行排序操作__

> 折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。——《大话数据结构》


### 插值查找

基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。

> 对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择

### 斐波那契查找

斐波那契序列：F(1)=1，F(2)=1，F(n)=f(n-1)+F(n-2) （n>=2）。1、1、2、3、5、8、13、21、34、55、89

又称黄金分割查找，基于二分查找算法，根据斐波那契数列进行分割。

1. 将原查找表扩展为长度为F[n]，如果要补充元素，则补充重复最后一个元素，直到满足F(n)=f(n-1)+F(n-2)
2. 完成后进行斐波那契分割，即F[n]个元素分割为前半部分F[n-1]个元素，后半部分F[n-2]个元素
3. 递归重复1、2，直到查找完成

+ 时间复杂度：O(log2N)

## 二叉树(Binary Tree)

[Javascript代码看这里](../code/search/search_tree.js)

二叉树的分类：
+ 满二叉树：从高到低，除了叶节点外，所以节点左右节点都存在。
+ 完全二叉树：比满二叉树少几个叶节点，从左向右放子节点。
+ 二叉搜索树：空树或者二叉树的所有节点比他的左子节点大，比他的右子节点小。
+ 平衡二叉树：空树或者它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树也都是平衡树。
+ 红黑树：具有平衡二叉树、二叉搜索树的特点，有序且子树差不超过1。颜色规则：根节点和特殊节点（即叶节点下面两个虚无的节点和未填写的节点）是黑的，红节点的左右子节点是黑的，最重要的是对于每个节点，从该节点到子孙叶节点的所有路径包含相同数目的黑节点。

[平衡二叉树、B树、B+树、B*树](https://zhuanlan.zhihu.com/p/27700617)

1. 二叉树的查找
2. 二叉树的遍历
    + 前序遍历：根-左-右
    + 中序遍历：左-根-右
    + 后序便利：左-右-根
3. 二叉树的添加
4. 二叉树的删除

### 二叉搜索树(Binary Search Tree)

二叉搜索树的特点
+ 若左子树不空，则左子树上所有结点的值均小于它的根节点的值；
+ 若右子树不空，则右子树上所有结点的值均大于它的根结点的值
+ 左、右子树也分别为二叉排序树

### 平衡二叉树(AVL Tree)

平衡二叉树的特点
+ 一棵空树或它的左右两个子树的高度差的绝对值不超过1
+ 左右两个子树都是一棵平衡二叉树
+ 平衡二叉树必定是二叉搜索树
+ 常用算法有红黑树、AVL、Treap、伸展树等

最小平衡二叉树的节点数：F(n)=F(n-1)+F(n-2)+1 

## 状态空间搜索

### 深度优先算法(DFS)

从初始状态一层一层向下找，直到找到目标为止。可以用栈（stack）来实现，整个过程可以想象成一个倒立的树形

1. 把根节点压入栈中
2. 每次从栈中弹出一个元素，搜索所有在它下一级的元素，把这些元素压入栈中。并把这个元素记为它下一级元素的前驱
3. 重复2，直到找到所需元素或遍历结束

### 广度优先算法(BFS)

按照一定的顺序前查找完一个分支，再查找另一个分支，以至找到目标为止。可以用队列（queue）来实现，整个过程也可以看做一个倒立的树形：

1. 把根节点放到队列的末尾
2. 每次从队列的头部取出一个元素，查看这个元素所有的下一级元素，把它们放到队列的末尾。并把这个元素记为它下一级元素的前驱
3. 重复2，直到找到所需元素或遍历结束

### 启发式搜索

深度优先、广度优先都是在一个给定的状态空间中穷举。在状态空间不大的情况下是很合适的算法，可是当状态空间十分大，他的效率实在太低，甚至不可完成。启发式搜索就是在状态空间中的搜索对每一个搜索的位置进行评估，得到最好的位置，再从这个位置进行搜索直到目标。

启发式搜索常用算法： 蚁群算法，遗传算法、模拟退火算法

+ 蚁群算法：一种用来寻找优化路径的概率型算法，具有分布计算、信息正反馈和启发式搜索的特征
+ 遗传算法：模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，通过模拟自然进化过程搜索最优解的方法
+ 模拟退火算法：

## 分块查找

## 哈希查找

<!-- 
平衡搜索树(AVL Tree)
https://www.cnblogs.com/zhangbaochong/p/5164994.html

深度优先(Depth First Search)
广度优先(Breadth First Search)
http://blog.csdn.net/weishenmetlc/article/details/51545226

启发式搜索(Heuristic Search) 

并查集(Union-Find Set)
哈希(Hashing)

最优化剪枝

可行性剪枝

记忆化搜索

枚举搜索(Enumeration)

-->