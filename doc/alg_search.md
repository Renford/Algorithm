
## 查找算法的基本概念

1. 无序查找：被查找数列有序无序均可
2. 有序查找：被查找数列必须为有序数列
3. 静态查找和动态查找：静态或者动态都是针对查找表而言的
4. 平均查找长度（Average Search Length，ASL）：需和指定key进行比较的关键字的个数的期望值

## 常见查找算法

### 顺序查找

属于无序查找算法，从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。

时间复杂度：O(N)

### 有序表查找

#### 折半查找

又叫二分查找，被查找值递归与有序列表的中间值比较
    1. 等于，则查找成功
    2. 大于，则右半继续二分查找
    3. 小于，则左半继续二分查找

复杂度分析：最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)

__元素必须是有序的，如果是无序的则要先进行排序操作__

> 折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。——《大话数据结构》


#### 插值查找

基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。

> 对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择

#### 斐波那契查找

斐波那契序列：F(1)=1，F(2)=1，F(n)=f(n-1)+F(n-2) （n>=2）。1、1、2、3、5、8、13、21、34、55、89

又称黄金分割查找，基于二分查找算法，根据斐波那契数列进行分割。

1. 将原查找表扩展为长度为F[n]，如果要补充元素，则补充重复最后一个元素，直到满足F(n)=f(n-1)+F(n-2)
2. 完成后进行斐波那契分割，即F[n]个元素分割为前半部分F[n-1]个元素，后半部分F[n-2]个元素
3. 递归重复1、2，直到查找完成

+ 时间复杂度：O(log2N)

### 树表查找

### 二叉树(Binary Tree)

二叉树的分类：
+ 满二叉树：从高到低，除了叶节点外，所以节点左右节点都存在。
+ 完全二叉树：比满二叉树少几个叶节点，从左向右放子节点。
+ 平衡二叉树：空树或者它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树也都是平衡树。
+ 二叉搜索树：空树或者二叉树的所有节点比他的左子节点大，比他的右子节点小。
+ 红黑树：具有平衡二叉树、二叉搜索树的特点，有序且子树差不超过1。颜色规则：根节点和特殊节点（即叶节点下面两个虚无的节点和未填写的节点）是黑的，红节点的左右子节点是黑的，最重要的是对于每个节点，从该节点到子孙叶节点的所有路径包含相同数目的黑节点。

1. 二叉树的查找
2. 二叉树的遍历
    + 前序遍历：根-左-右
    + 中序遍历：左-根-右
    + 后序便利：左-右-根
3. 二叉树的添加
4. 二叉树的删除

#### 二叉搜索树(Binary Search Tree)

二叉搜索树特点
+ 若左子树不空，则左子树上所有结点的值均小于它的根节点的值；
+ 若右子树不空，则右子树上所有结点的值均大于它的根结点的值
+ 左、右子树也分别为二叉排序树

#### 平衡搜索树(AVL Tree)

#### 深度优先算法

#### 广度优先算法



### 分块查找

### 哈希查找

<!-- 

二叉搜索树(Binary Search Tree)
平衡搜索树(AVL Tree)
并查集(Union-Find Set)
哈希(Hashing)

最优化剪枝

可行性剪枝

记忆化搜索

枚举搜索(Enumeration)

深度优先(Depth First Search)

广度优先(Breadth First Search)

启发式搜索(Heuristic Search) 

-->