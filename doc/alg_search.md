
## 查找算法的基本概念

1. 无序查找：被查找数列有序无序均可
2. 有序查找：被查找数列必须为有序数列
3. 静态查找和动态查找：静态或者动态都是针对查找表而言的
4. 平均查找长度（Average Search Length，ASL）：需和指定key进行比较的关键字的个数的期望值

## 常见查找算法

### 顺序查找

属于无序查找算法，从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。

时间复杂度：O(N)

### 有序表查找

#### 折半查找

又叫二分查找，被查找值递归与有序列表的中间值比较
    1. 等于，则查找成功
    2. 大于，则右半继续二分查找
    3. 小于，则左半继续二分查找

复杂度分析：最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)

__元素必须是有序的，如果是无序的则要先进行排序操作__

> 折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。——《大话数据结构》


#### 插值查找

基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。

> 对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择

#### 斐波那契查找

斐波那契序列：F(1)=1，F(2)=1，F(n)=f(n-1)+F(n-2) （n>=2）。1、1、2、3、5、8、13、21、34、55、89

又称黄金分割查找，基于二分查找算法，根据斐波那契数列进行分割。

1. 将原查找表扩展为长度为F[n]，如果要补充元素，则补充重复最后一个元素，直到满足F(n)=f(n-1)+F(n-2)
2. 完成后进行斐波那契分割，即F[n]个元素分割为前半部分F[n-1]个元素，后半部分F[n-2]个元素
3. 递归重复1、2，直到查找完成

+ 时间复杂度：O(log2N)

#### 树表查找

#### 分块查找

#### 哈希查找

<!-- 

二分查找(Binary Search)

树型

二叉搜索树(Binary Search Tree)
平衡搜索树(AVL Tree)
并查集(Union-Find Set)
哈希(Hashing)

最优化剪枝

可行性剪枝

记忆化搜索

枚举搜索(Enumeration)

深度优先(Depth First Search)

广度优先(Breadth First Search)

启发式搜索(Heuristic Search) 

-->