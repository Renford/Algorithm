
## 排序相关的的基本概念

+ 时间复杂度：用算法执行中的数据比较次数与数据移动次数来衡量。
+ 空间复杂度：算法执行时所需的附加存储。
+ 稳定性：序列中俩个相等的元素，若排序前后相对位置不变则为稳定排序，否则为不稳定
+ 内排序：指在排序期间数据对象全部存放在内存的排序；
+ 外排序：指在排序期间全部对象个数太多，不能同时存放在内存，必须根据排序过程的要求，不断在内、外存之间移动的排序。

## 交换类

[Javascript代码看这里](../code/sorts/sort_exchange.js)

#### 冒泡排序

每次循环找出未排序序列中的最大值放在序列末尾

1. 依次比较相邻两个元素，前者大则交换，最大值放最后
2. 以此类推，直到排序完成

+ 时间复杂度：O(n^2)
+ 空间复杂度：O(1)

#### 快速排序

1. 设定待排数组arr，temp = arr[0], i=start，j=end
2. temp与arr倒序比较，找出最后一个比temp小的元素，假定下标为j, 并将arr[i]赋值为arr[j]
3. temp与arr顺序比较，找出第一个比temp大的元素，假定下标为i，并将arr[j]赋值为arr[i]
4. 重复2、重复3，
5. 依次类推，i==j，第一次排序完成
6. 递归1-5查找(0~i-1)、(i+1~n-1)

时间复杂度：最坏情况，数组倒序时为O(n^2)；最好情况，数组顺序时为O(n*logn)
+ 空间复杂度：O(1)

## 选择类

[Javascript代码看这里](../code/sorts/sort_select.js)

#### 选择排序

1. 从未排序的序列选择最小值，与第一个元素交换
2. 以此类推，直到排序完成

+ 时间复杂度：O(n^2)
+ 空间复杂度：O(1)

#### 堆排序

堆排序（HeapSort）是一树形选择排序。堆排序的特点是：在排序过程中，将R[l..n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系（参见二叉树的顺序存储结构），在当前无序区中选择关键字最大（或最小）的记录

1. 构建堆，即按照数组顺序构建一颗二叉树
2. 堆调整，比较每一个非叶子节点的左右子树和本身，使该节点值大于左右子树的值
3. 堆排序，将堆的根节点取出与最后一个节点（每次向前推进一个）进行交换
4. 将无需序列，重复2，重复3，直到数组有序，排序完成

+ 时间复杂度：O(N*logN)，其中建堆：O(N)，每次堆调整：O(logN)
+ 空间复杂度：O(1）

## 插入类

[Javascript代码看这里](../code/sorts/sort_insert.js)

#### 插入排序

+ 直接插入排序 

1. 假定第一个元素是有序的
2. 从有序序列的下一个元素开始，与有序序列倒序比较，比新元素大则后移，直到新元素可以放入有序序列
3. 重复2
4. 依次类推，直到排序完成

+ 时间复杂度：最坏情况，数组倒序时为O(n^2)；最好情况，数组顺序时为O(n)
+ 空间复杂度：O(1)

+ 折半插入排序

+ 链表插入排序

#### 希尔排序
直接插入排序的改进版，即分组插入排序

1. 按一定增量d(一般为数组长度的一半)将数组分组，每组内使用直接插入排序
2. 再取d的一半，重复执行1
3. 当d==1，序列所有数组分为一组，使用插入排序

+ 时间复杂度：跟增量d有关，但小于直接插入排序的O(n^2)
+ 空间复杂度：O(1)

## 归并类

[Javascript代码看这里](../code/sorts/sort_merge.js)

#### 归并排序

为稳定排序，适用于局部有序序列更有优势。

1. 分组，按照gap=1将数组分组
2. 合并，开辟一个新空间长度为2*gap，将两个相邻的小组合并，并使合并后有序
3. 写回原始数组的相应位置
4. gap翻倍，重复1、2、3，直到gap大于数组的长度

+ 时间复杂度：O(N * log N) 
+ 空间复杂度：O(N)

## 分布类

[Javascript代码看这里](../code/sorts/sort_distribute.js)

#### 桶排序

把待排序元素分散到不同的桶里面，每个桶再使用桶排序再分别排序。为稳定排序，对数据的条件有特殊要求。一般对数据量较大. 但重复数据较多的排序较有优势。

1. 创建M个有序桶，一般采用链表方式存储
2. 将待排序序列分散到桶中
3. 每个桶内采用桶或其他排序方法排序
4. 按桶序号输出即可

假定数据量为N，桶个数为M
+ 时间复杂度：平均为O(N+C)，其中C=N*(logN-logM)，最好为O(N)
+ 空间复杂度：O(N+M)

#### 基数排序

+ MSD：最高位优先(Most Significant Digit first)法
    1. 先按k1排序分组，同一组中记录，关键码k1相等，
    2. 按顺序收集序列，再对k2重复1操作，
    3. 对后面的关键码继续这样的排序分组，直到按最次位关键码kd对各子组排序后。
    4. 再将各组连接起来，便得到一个有序序列。
+ LSD：最低位优先(Least Significant Digit first)法
    先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。

+ 时间复杂度：O(d(n+radix))，其中，一趟分配时间复杂度为O(n)，一趟收集时间复杂度为O(radix)，共进行d趟分配和收集
+ 空间复杂度：O(2*radix)

## 并发类

## 混合类

## 其他类


交换类排序 - 冒泡排序 快速排序 鸡尾酒排序 奇偶排序 梳子排序 侏儒排序 臭皮匠排序 Bogo排序
选择类排序 - 选择排序 堆排序 Smooth排序 笛卡尔树排序 锦标赛排序 圈排序
插入类排序 - 插入排序 希尔排序 二叉查找树排序 图书馆排序 耐心排序
归并类排序 - 归并排序 梯级归并排序 振荡归并排序 多相归并排序 Strand排序
分布类排序 - 桶排序 基数排序 计数排序 珠排序 美国旗帜排序 爆炸排序 鸽巢排序 相邻图排序 闪电排序 插值排序
并发类排序 - 双调排序器 Batcher归并网络 两两排序网络
混合类排序 - Tim排序 内省排序 Spread排序 反移排序 J排序
其他类排序 - 拓扑排序 煎饼排序 意粉排序
http://raychase.iteye.com/blog/1991794
